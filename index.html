<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>jdybnis/memcached @ GitHub</title>

    <style type="text/css">
      body {
        margin-top: 1.0em;
        background-color: #cfd5d8;
        font-family: "helvetica";
        color: #000000;
      }
      #container {
        margin: 0 auto;
        width: 700px;
      }
      h1 { font-size: 2.8em; color: #302a27; margin-bottom: 3px; }
      h1 .small { font-size: 0.4em; }
      h1 a { text-decoration: none }
      h2 { font-size: 1.5em; color: #302a27; }
      h3 { text-align: center; color: #302a27; }
      a { color: #302a27; }
      .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
      .download { float: right; }
      pre { background: #000; color: #fff; padding: 15px;}
      hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
      tt { font-size: larger }
      .footer { text-align:center; padding-top:30px; font-style: italic; }
    </style>

  </head>

  <body>
    <div id="container">

      <div class="download">
        <a href="http://github.com/jdybnis/memcached/zipball/master">
          <img border="0" width="90" src="http://github.com/images/modules/download/zip.png"></a>
        <a href="http://github.com/jdybnis/memcached/tarball/master">
          <img border="0" width="90" src="http://github.com/images/modules/download/tar.png"></a>
      </div>

      <h1>
        <a href="http://github.com/jdybnis/memcached">memcached-prefix</a><br>
        <span class="small">by <a href="http://github.com/jdybnis">jdybnis</a></small>
      </h1>

      <div class="description">
        <p>This is an experimental fork off of the memcached 1.3 development branch. It adds commands
        <b>pget</b> and <b>pdelete</b> that operate on ranges of keys having a common prefix. It also
        adds a memcachedb compatible <b>rget</b> command.</p>
        <p>The main internal change is that the cache is implemented with a skiplist instead of the
        normal hashtable. Even so, its performance is very close to the standard memcached (see the
        benchmarks below). Space usage is also roughly unchanged.  Each item in the skiplist has
        an average of 4 bytes more overhead than it would in the hashtable.</p>
      </div>

      <h2>New Protocol Commands</h2>

      <pre>pdelete key_prefix</pre>
      <p><tt>pdelete</tt> instructs the server to delete all items that have keys beginning in <tt>key_prefix</tt>.
      <tt>key_prefix</tt> must not be the empty string. Use the flush command instead if you wish to delete all the
      items in the cache.</p>

      <pre>pget key_prefix max_items [continue_key]</pre>
      <p><tt>pget</tt> instructs the server to send all the items that have keys beginning with the 
      specified <tt>key_prefix</tt>. The server will send the items in lexographic key order. <tt>max_items</tt>
      is the maximum number of items that the server will send in response to a single <tt>pget</tt> command. 
      <tt>max_items</tt> cannot be greater than 100. To retrieve more than <tt>max_items</tt> the client can 
      issue multiple <tt>pget</tt> commands that use the <tt>continue_key</tt>.</p>
      <p>If a <tt>pget</tt> command includes a <tt>continue_key</tt> then the server will only send back items 
      that lexographically follow after the <tt>continue_key</tt>.</p>
      <p>When the server sends back a number of items equal to <tt>max_items</tt>, then the client should assume
      that there are more items on the server matching the <tt>key_prefix</tt>. To retreive the remaining items
      the client should remember the key of the last item it received and issue another <tt>pget</tt> with that
      key as the <tt>continue_key</tt>. The server will respond with the next batch of items following the 
      <tt>continue_key</tt> in lexographic order.</p>

      <pre>rget start end start_is_open end_is_open <tt>max_items</tt></pre>
      <p><tt>rget</tt> is the same as the command in memcachedb. See the 
      <a href="http://memcachedb.googlecode.com/svn/trunk/doc/rget.txt">memcachedb documentation</a>
      for usage instructions.</p>

      <p><i>Note: these commands are not standard and may very well change between versions.</i></p>

      <h2>Benchmarks</h2>
      <p>The following measurments compare the performance of memcached-prefix and the standard
      memcached v1.3.</p>
      <h3>Setup</h3>
      <p>The benchmarks were run on a Core i7 920 w/ 12GB RAM and HT enabled. The client was libmemcached
      based, running in loopback mode against a multi-threaded server on the same machine.</p>
      <p>Each benchmark run starts out by loading items into an empty cache until it contains a specific
      number of items (the x axis of the graphs below). Then for a period of 10 seconds the client issues
      random commands in the ratio of 90% get, to 5% add, to 5% delete, and measures the number of
      operations completed per second. The numbers used to build the graphs are averages of multiple
      runs.</p>
      <h3>Results</h3>
      <p>The performance measurements show that there is a remarkably small decrease in throughput
      between the standard version of memcached (hashtable based) and memcached-prefix (skiplist
      based). Although the skiplist based version drops in throughput slightly more than the
      standard hashtable version as the number of items in the cache increases, <b>the throughput
      of memcached-prefix is close to 100,000 ops/sec, in the worst case tested, with 100 million
      items in the cache</b>.</p>
      <img src="compare.png">
      <p>Note: The keys and values used in the above benchmark were all 8 bytes to allow more items to 
      fit in the cache than normal, thereby simulating a server with much more RAM. The following graph
      shows that using larger keys and values only changes the results by a small constant factor.</p>
      <img src="sizes.png">

      <h2>Download</h2>
      <p> You can download this project in either
      <a href="http://github.com/jdybnis/memcached/zipball/master">zip</a> or
      <a href="http://github.com/jdybnis/memcached/tarball/master">tar</a> formats.  </p>
      <p> You can also clone the project with <a href="http://git-scm.com">Git</a> by running:
      <pre>$ git clone git://github.com/jdybnis/memcached</pre> </p>

      <div class="footer">
        get the source code on GitHub : <a href="http://github.com/jdybnis/memcached">jdybnis/memcached</a>
      </div>

      <h2>Contact</h2>
      <p>Josh Dybnis (fist letter of firstname followed by entire lastname, at gmail.com)</p>

    </div>

    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
      </script>
      <script type="text/javascript">
        try {
          var pageTracker = _gat._getTracker("UA-6252904-2");
          pageTracker._trackPageview();
        } catch(err) {}</script>
    </body>
  </html>
